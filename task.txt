01. Написать класс "вектор" с операциями +(сложение), -(вычитание), *(умножение на число), [ ](доступ к координатам)

02. Написать генераторную функцию, которая возвращает все перестановки данного списка. (без itertools.permutations) (40 баллов)

03. Написать функцию, которая считает определитель данной матрицы (matrix=[[...],[...],[...],...,[...]].

04. Написать функцию, возвращающую True или False, если число является александрийским.

05. Написать функцию, которая принимает на вход матрицу (список списков) и возвращает матрицу, повернутую на -90 градусов.
    Если на вход идёт не список списков, то выдать TypeError, если на входе не матрица, то выдать ValueError (30 баллов)

06. Написать менеджер контекста, который принимает callback и reraise, если reraise True прокидывать исключения по стеку вверх,
    иначе вызывать callback, передавая ему ошибку и стек вызовов (и ещё что-то) (40 баллов)

07. Написать функцию, выполняющую слияние нескольких файлов. (Принимает имя итогового файла и сами файлы)

08. Написать функцию-декоратор, который принимает типы или списки типов и проверяет что параметры, передаваемые в функцию,
    соответствуют указанным типам. Если один из переданных параметров не соответствует ни одному из типов,
    выкинуть исключение TypeError. (40 баллов)

09. Написать функцию которая принимает на вход строку и возвращает строку, из которой удалены все слова, повторяющиеся подряд.
    Сделать это с помощью регулярных выражений. (30 баллов)

10. Написать функцию которая принимает на вход число и возвращает для него значение функции Эйлера (30 баллов)

11. Дана строка из символов, вывести список в формате (символ, число повторений), отсортированный по убыванию частоты вхождения
    символа в строку. Если частота одинаковая, первым выводить лексикографически меньший символ.
    Считать регистронезависимо (т.е строку привести в нижний регистр) (30 баллов)

12. Дан текст, в котором присутствуют даты в формате d.hh:mm:ss (d. или d.hh: могут отсутствовать).
    Нужно сложить все эти даты и вывести результирующую в том же формате. (30 баллов)

13. Написать функцию, которая принимает на вход вектор (список), в котором в порядке убывания степеней записаны коэффициенты
    многочлена над полем Z. Вернуть все его корни в порядке убывания.

14. Написать декоратор, который будет считать кол-во вызовов функции, сохраняя это кол-во в атрибут calls

15. Написать, функцию, которая принимает два итератора и возвращает расстояние Хэминга между этими итераторами.

16. Написать функцию, принимающую СЛАУ в виде списка уравнений, представленных в виде (список_коэффициентов, свободный член),
    а на выход предоставляющую None, если решений нет, иначе одно решение в виде списка. (40 баллов)

17. Написать кэширующий декоратор, для функции f, если f(x) и f(x=) можно считать разными вызовами(40 баллов).

18. Написать генератор возвращающий пары простых чисел-близнецов (отличающихся на 2)(30 баллов)

19. Написать функцию выполняющую слияние файлов, принимающую имя файла для вывода и *args имён файлов для слияния(30 баллов)

20. Функция, принимающая итератор строк, которая возвращает только те строки, которые отсортированы лексикографически(30)

21. На вход подаются два итератора написать генераторную функцию, которая возвращает декартово произведение по схеме

22. На вход подается строка, в которой встречается дата в формате dd.mm.yyyy, ее надо заменить в этой строке на формат yyyy-mm-dd
    На самом деле меня вообще напрягают бесполезные и бесячие по моему мнению вещи. Это просто так сильно меня выматывает
    Примерно на 20 баллов

23. Реализовать декоратор call_count на функцию, подсчитывающий количество вызовов функции.
    Количество вызовов должно сохраняться в атрибута calls функции.

24. Пусть дано натуральное число k. Обозначим S(k) сумму цифр числа k.
    Реализовать функцию, принимающую натуральное число k и возвращающую (S(...S(k)...)).
    S применяются для тех пор, пока не останется одна цифра.
    При реализации ЗАПРЕЩЕНО использовать циклы for, while а также if

25. Реализовать функцию принимающую натуральное число и возвращающую количество простых множителей в разложении числа.
    Если передано не число выбросить typeerror. Если передано не натуральное число то valueerror

26. Реализовать генераторную функцию, принимающую итератор произвольных объектов и возвращающую их без повторений.
    Порядок следования объектов должен сохраниться.

27. Написать функцию, дается на вход две строки, вернуть сдвиг если вторая строка это циклический сдвиг первой,
    если хотя бы один аргумент не строка выкинуть TypeError(30 баллов):

28. Написать генераторную функцию, возвращающую подмножества множества. itertools.combinations использовать нельзя: (30 баллов)

29. Пусть панграмма это такая строка в которой содержатся все буквы алфавита. Пример такой фразы:
    The quick brown fox jumps over the lazy dog. Написать такую функцию определяющую является ли строка панграммой.
    На вход функции подается сама строка и алфавит.
    (30 баллов)(превратить строку в set и проверить вложенность алфавита в set от строки)

30. Реализовать RLE-упаковщик и распаковщик. Первое принимает итератор и выдает упакованный итератор,
    второе принимает упакованный итератор, выдает распакованный. (30 баллов)

31. Реализовать декоратор `with_retries`, принимающий в качестве параметра натуральное число `n`. При вызове функции,
    к которой применён декоратор, необходимо сделать не более `n` попыток вызова, пока функция не отработает без исключения
    (исключениями считать классы Exception и его предков); в противном случае пробросить крайнее исключение. (40 баллов)

32. Реализовать функцию sum_time, принимающую текст, содержащий время в формате d.hh:mm:ss (части d. и d.hh: могут отсутствовать)
    и возвращающую сумму времён. Результатом должна быть строка в аналогичном формате.

33. Реализовать функцию roots, принимающую вектор (список) коэффициентов многочлена (заданы по убыванию степеней) над кольцом ℤ
    и возвращающую список, который содержит все целые корни многочлена в порядке убывания.

34. Реализовать класс Rational рациональных чисел с арифметическими операциями +, -, *, /.
    Арифметика также должна работать с аргументами типа целых чисел.
    Пример использования: 4 - (Rational(1, 3)*3 + 1)/Rational(2)

35. Реализовать генераторную функцию cross, принимающую два итератора иd
    выдающую их декартово произведение по схеме (цифрами указан порядок выдачи элементов):
        ```
           a  b  c …
        A  1  3  6
        B  2  5  9

36. Реализовать декоратор check_types, принимающий типы (или списки типов) и проверяющий, что параметры функции,
    к которой применён декоратор, являются объектами соответствующих типов или их подклассами.
    В случае несоответствия выбрасывать исключение TypeError.

37. Реализовать кэширующий декоратор cache. Вызовы f(1) и f(x=1) можно считать различными для функции f(x),
    к которой данный декоратор применён.

38. Реализовать менеджер контекстов open_files(*filenames, mode, encoding), открывающий заданные файлы в указанном режиме
    и кодировке. Пример использования:
        with open_files(‘1.txt’, ‘2.txt’, mode=’r’, encoding=’cp866’) as (f, g):
            print(f.read(), g.read())

39. Реализовать функцию `print_matrix`, принимающую матрицу, заданную в виде списка списков, элементы матрицы
    - вещественные числа. Функция должна вывести матрицу чисел на экран так, чтобы значения в столбцах были выровнены по правому
    краю, все столбцы имели одинаковый размер и каждое число выведено с точностью до 2-х знаков после запятой.
    Столбцы друг от друга разделять двумя пробелами.

40. Реализовать функцию `solve`, принимающую числовую функцию `f(x)`, действительные числа `a` и `b`, точность `eps`
    (по умолчанию примем равной `1e-10`). Функция должна вернуть одно из решений уравнения `f(x) = 0` на отрезке `[a; b]`
    с (абсолютной) точностью `eps`; либо выбросить исключение `ValueError`, если `f(a) < 0` или `f(b) > 0`.

41. Реализовать декоратор `debug`, принимающий в качестве параметра file-like object и печатающий в него название функции,
    параметры её вызова, результат и время работы (в секундах), согласно примерам:
        ```
        1.5 func1(1, 2) -> 3
        0.5 func1(‘1’, y=2) -> 12
        2.04 func1(‘a’, ‘’) -> TypeError(‘y’)
        ```

42. Реализовать функцию find_last, принимающую упорядоченный по неубыванию список объектов и элемент.
    Функция должна найти последнее вхождение элемента в список, используя бинарный поиск и вернуть индекс вхождения (число).
    Если вхождения нет, вернуть None.

43. Реализовать класс Queue с методами enqueue (добавить элемент в очередь, принимает элемент для добавления в очередь), 
    dequeue (удалить элемент из очереди), empty (проверить, пуста ли очередь, возвращает True или False), 
    front (получить первый элемент), back (получить последний элемент).
